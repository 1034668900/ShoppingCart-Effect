### 原生js面向对象编程思想实现购物车效果

#### 购物车效果面向对象编程思想
- 首先**针对每个商品**创建一个类，类里包含对单件商品的所有属性和方法
- 其次**针对整个界面数据**创建一个类，类里包含整个界面需要用到的数据和方法，且对单个商品类中的方法进行重新封装
- 然后**针对整个UI界面**创建一个类，在UI类的构造函数中可以通过创建界面数据类的实例对象拿到该类的所有数据和方法，并对这些方法再次封装（**再次封装的目的就是希望最终只需要一个UI类的实例对象便可实现所有的功能**），通过该类实现界面的UI渲染以及实现各种效果的方法
- 最后**创建UI界面的实例对象**拿到所有数据和方法，再根据需要**绑定相关事件**即可

#### 购物车效果面向对象编程思想的优点
- **整个过程逻辑清晰，最后只需要一个实例对象便可以操作所有属性和方法**
- **便于维护和扩展**
- **代码可阅读性高**


### js部分实现整体思路

- 因为我们需要根据后台传入的商品数据来渲染商品列表，因此可以首先写一个关于创建单个商品的类对象(**CreateUIGoods**)
    - 在这个类对象大致中包括
        - 在构造函数中重新封装源数据(避免操作源数据)，添加商品选中数量的属性
        - 在类中添加对单价商品操作的方法
            1. 计算单价商品总价
            2. 判断商品是否选中
            3. 添加商品
            4. 减少商品
    
- 然后创建整合整个界面数据的类(**UIData**)
    - 在这个类中大致包括
        - 通过循环遍历数据，调用**CreateUIGoods类**来获得一个包含每个商品数据的**数组**
        - **重新封装**CreateUIGoods类中**针对单个商品操作的所有方法**，使得在该类中调用对应方法**并传入商品对象下标**就可实现对应功能
        - 并添加部分**UI界面商品数据的操作方法**
            1. 计算购物车中商品总价
            2. 计算购物车中商品总的选中数量
            3. 判断购物车中是否有商品
            4. 判断购物车中商品总价格是否超过起送费
            5. ...

- 接着创建整个界面UI的类(**UI**)
    - 首先通过 ```let uiData = new UIData()``` 拿到整个界面的数据
    - 根据需要获取DOM元素
    - 根据商品列表的数据创建商品列表并将其渲染至页面
        - **两种实现思路：**
            1. 利用模板字符串生成HTML字符串再添加到父元素
                - **有解析HTML的过程**，**执行效率较低**，但是**开发效率高**
            2. 一个一个元素的创建并将其添加到父元素
                - **执行效率高**，但是**开发效率低**
        - 但是**永远不要优先考虑效率**，因此尽量先选择第一种实现思路，在最后真的出现效率问题时再针对性优化
    - 再次重新封装UIData类中对商品数据操作的方法，使得只通过UI类便可实现对整个商品界面的所有操作
    - 添加一些UI界面需要的方法
        1. **更新页脚**
        2. **更新商品显示状态**(商品减号按钮在商品选中数量为0时隐藏)
        3. **添加商品后购物车的动画**
        4. **添加商品后加号按钮过渡动画**
            - **实现思路：**
                1. 获取点击的对应商品DOM对象，并根据该商品寻找加号按钮这个子元素获得其矩形信息(**getBoundingClientRect**())，从而**获得起点位置start**
                2.**创建**与加号按钮样式大小完全相同的div元素，并将其移至start位置处
                3. 获得购物车位置处的矩形信息，从而**获得目标位置target**
                4. 在对div元素设置transform属性使其移动至目标位置
                5. 在对应元素的类样式中设置过渡效果便可实现动画
            - **注意细节：**
                1. 在上述步骤中中步骤2 --> 步骤4 时，直接这样写是不会有效果的，因为**渲染进程中执行js时，会先将js执行完毕后再进行渲染，后面的移动div操作会覆盖之前的**，因此此时是**看不到**任何**动画效果**的，只能看到加号直接出现在目标位置target
                2. 我们可以通过在步骤2 --> 步骤4 的中间，对DOM树上的任何属性进行读取``` div.clientHeight ```，使其**强行渲染**，就可实现动画效果
                3. 在过渡效果实现过程的方法中，由于**目标位置target的位置数据是始终不会变化**的，因此可以将该数据的获取**提出**并**添加为该类的属性**，但是开始位置start的位置数据是根据点击不同商品的加号按钮确定的，因此不能提出
                4. 在每次动画执行完毕时，都应该为该加号按钮添加动画事件执行完毕的监听事件，在监听事件的回调中删除该加号按钮元素，防止元素不断生成；同时**在动画执行结束后应调用商品成功添加购物车的动画的事件**,并且由于点击加号时会发生i元素到div元素的**冒泡**，从而导致监听事件每次都会执行两次，因此添加**配置项**{once:true}使其只触发一次
                ``` div.addEventListener('transitionend',() => {}, {once:true}) ```

- 根据交互要求，为相应操作绑定事件
    - **小细节**
        - 在为每个商品加号按钮绑定点击事件时，需要直到点击的是哪个商品，此时获取index下标的方法有两种
            1. 根据当前点击的+号不断向上找父元素，直到找到每个商品项然后判断在div中的index
                - 显然非常的繁琐
            2. 在**创建每个商品时就为加号按钮的div设置index属性并传入对应的index**   (更简单)
                - 使用时通过 ```+e.target.getAttribute('index') ``` 便可获取该加号按钮的index属性
            


